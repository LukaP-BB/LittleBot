import discord          #on fait un bot pour discord, c'est de premi√®re n√©cessit√©
import random           #importe la bilbioth√®que n√©cessaire pour cr√©er de l'al√©atoire
import math             #importe le module math pour la valeur aboslue
import re               #importe les expressions r√©guli√®res
import datetime         #importe la date du jour et des m√©thodes en rapport
import time             #permet d'utiliser sleep
import json             #pour interragir avec des fichiers json
import os               #pour interragir avec le syst√®me, lancer des commandes en bash par exemple
import subprocess       #m√™me id√©e

from discord.ext import commands

bot = commands.Bot(command_prefix = '$' ) #cr√©ation du pr√©fixe qui servira √† dire "ceci est une commande"

#************* JEU DE HASARD ***************************************************

@bot.command(help="Un petit jeu pour tuer le temps : il faut taper $score suivi d'un guess entre 0 et 100. Le bot trouve un nombre myst√®re al√©atoire et fait la diff√©rence avec ton guess. Plus celle-ci est petite, plus tu es lucky")                           #commande $score : permet de faire un guess et d'obtenir la diff√©rence avec ce guess
async def score(ctx, guess):

    random.seed()                           #initialise la seed et
    score = random.randint(0,100)           #renvoie un nb pseudo al√©atoire dans l'intervalle [0;100]

    guess = int(guess)
    delta = abs(score-guess)  # 2 lignes pour calculer la diff√©rence absolue entre le guess et le score obtenu (abs vient de la biblioth√®que math)

    await ctx.send('nombre myst√®re : {}'.format(score)) #renvoie le r√©sultat en msg discord
    await ctx.send('diff√©rence : {}'.format(delta))     #renvoie la diff√©rence

    from datetime import date
    today = date.today()       #2 lignes pour √©crire la date d'obtention du score

    resultats = open("resultats.txt","a")   #ouvre le fichier resultats.txt en mode "append" : chaque √©criture se fait √† la suite de ce qui est d√©j√† √©crit
    resultats.writelines([str(ctx.message.author), " : " ,str(delta), " : ", str(today),"\n"]) #ecrit le nom d'utilisateur, le score et la date dans chaque nouvelle ligne du .txt
    resultats.close()   # a priori utile de fermer le fichier une fois √©crit pour pouvoir l'ouvrir dans une autre commande

# gestion d'erreurs pour le mini jeu
@score.error
async def score_error(ctx, error):
    if isinstance(error, commands.MissingRequiredArgument):
        await ctx.send("Il faut mettre un nombre apr√®s $score")
    elif(error, commands.CommandInvokeError):
        await ctx.send("$score n'accepte pas les chaines de caract√®res :rage:")
    else:
        await ctx.send("erreur")

# COMMANDE BEST
@bot.command(help="Cette commande renvoie le nom d'utilisateur ayant eu le meilleur delta par rapport √† son guess.\nLes r√©sultats sont rentr√©s dans un fichier quand $score est appel√©, et cette commande lit le fichier qui en r√©sulte.")
#commande pour extraire celui ayant le meilleur guess, accompagn√© de la date
async def best(ctx):
    resultats = open("resultats.txt", "r")
    min = 101
    for i, line in enumerate(resultats):
        match = re.search('(: )(\d?\d)( :)', line) #chaque expression entre parenth√®se correspond √† un groupe
        if match:
            score_obtenu = match.group(2)          #le group(2) fait r√©f√©rence aux deuxi√®mes parenth√®ses du match
            score_obtenu = int(score_obtenu)
            if (score_obtenu < min):
                min = score_obtenu
                match = re.search('[^0-9^#]*', line)
                if match:
                    nom = match.group(0)
                match = re.search('\d{4}-\d{2}-\d{2}', line)
                if match:
                    date = match.group(0)
        else:
            print("il n'y a pas encore de r√©sultat")
    await ctx.send("{} a obtenu le meilleur delta, √† savoir {} le {}".format(nom, min, date))


# ************* UNE SERIE DE FLORILEGES DE PHRASES TYPIQUES ********************

# SERRANO --------------
@bot.command(help="Quelques phrases typiques üòâ")
async def serrano(ctx):
    random.seed()                           #initialise la seed
    lol = ["Consid√©rez les pr√©fixes comme √©tant corrects",
            "N'oubliez pas, les distanciels c'est 80% du temps de travail !",
            "Merci √† Emmanuel Desmontils :heartpulse: :heart_eyes:",
            "On range son portable !",
            "FAITES PASSER LE PAQUET !!! :rage:",
            "Ne soyez pas non plus de mauvaise foi !",
            "UN PAQUET C'EST UNE COPIE",
            "Ne prenez pas mon stylo sinon on va tous √™tre malade :nauseated_face: ",
            "Faut √™tre plus pr√©cis",
            "Vous devez compl√©ter le tableau !"
            ]
    await ctx.send(lol[random.randint(0,(len(lol)-1))])

# MEKAOUCHE ------------------
@bot.command(help="Quelques phrases typiques üòâ")
async def mekaouche(ctx):
    random.seed()
    lol = ["Tu vas pas me salir, je vais pas te salir",
            "Et si on commen√ßait par 30 minutes pour d√©couvrir un nouveau language : Bash. Quoi ? vous avez eu des cours ?",
            "MAIS REGARDE DANS TON COURS !!",
            "Regarde dans ton cours..."]
    await ctx.send(lol[random.randint(0,(len(lol)-1))])


# GODART --------------
@bot.command(help="Quelques phrases typiques üòâ")
async def godart(ctx):
    random.seed()
    lol = ["on a r√©gl√© le probl√®me en supprimant l'individu",
    "Dans le cadre d'un management de projet on est plus sur un management de crise total que de management pro-actif",
    "C‚Äôest pas parce que c‚Äôest ma r√©ponse que vous devez mettre la mienne"]
    await ctx.send(lol[random.randint(0,(len(lol)-1))])

# TELETCHEA -----------------
@bot.command()
async def teletchea(ctx):
    cartouches = open("cartouches.txt","r")
    qte=cartouches.read()
    await ctx.send('{} articles se sont pris une cartouche :gun:'.format(qte))
    qte=int(qte)
    qte=qte+1
    cartouches.close
    cartouches = open("cartouches.txt","w")
    qte=str(qte)
    cartouches.write(qte)
    cartouches.close

#************* SUPPRESSION DE MESSAGES *****************************************

@bot.command(help="efface le nombre de messages indiqu√©", hidden=True)
@commands.has_permissions(manage_messages=True)
async def clear(ctx, nb_messages : int):
    await ctx.channel.purge(limit=nb_messages+1)

@clear.error
async def clear_error():
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("tu n'as pas les droits, loser !")
    elif (isinstance(error, commands.MissingRequiredArgument)):
        await ctx.send("Il faut mettre un nombre apr√®s $score")


#************* GESTIONS DE SALONS **********************************************
#cr√©ation de salons priv√©s
@bot.command(help="Ecrire la commande suivie du nom du salon.\nPour ecrire plusieurs mots, ecrire la phrase entre guillemets")
@commands.has_permissions(administrator=True)
async def salon(ctx, arg):   #nom de la commande
#cr√©ation du r√¥le
    guild = ctx.guild
    role = await guild.create_role(name=arg)

#cr√©ation du salon
    cat=ctx.channel.category #permet de connaitre la cat√©gorie du salon textuel, sinon le salon est cr√©√© tout en haut dans le serveur
    roles = {
    guild.default_role: discord.PermissionOverwrite(read_messages=False),
    role: discord.PermissionOverwrite(read_messages=True)
}
    await guild.create_text_channel(name=arg, overwrites=roles, category=cat)   #puis cr√©ation du salon avec le m√™me nom
@salon.error
async def salon_error():
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("tu n'as pas les droits, loser !")


#suppression des r√¥les et salons
@bot.command(help="Supprime un salon et un r√¥le\nDonner le nom du salon et du r√¥le en arguments de la commande\nPour les noms compos√©s de plusieurs mots, utiliser les guillemets")
@commands.has_permissions(administrator=True)
async def dels(ctx, ch : discord.TextChannel, rl : discord.Role):
    await rl.delete()
    await ch.delete()
@dels.error
async def dels_error():
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("tu n'as pas les droits, loser !")


#************ PARTIE COMPTAGE DES MESSAGES / EVENTS ****************************

#Comptage des messages, envoi de messages al√©atoire et r√©action aux messages ***
@bot.event
async def on_message(message):
    #partie comptage ---------
    if message.guild.id == 621610918429851649 :
        auteur=str(message.author)
        try :
            with open("rangs.json", "r+") as rangs:
                liste_auteurs=json.load(rangs)
                if auteur in liste_auteurs :
                    liste_auteurs[auteur] = liste_auteurs[auteur] +1
                else :
                    liste_auteurs[auteur] = 1
        except :
            pass
        try :
            with open("rangs.json", "w+") as rangs:
                rangs.write(json.dumps(liste_auteurs, sort_keys=True, indent=4))
        except :
            pass

    #partie envoi de message al√©atoire (en essayant de ne pas spam)
    if re.search('\?', (message.content)) and not message.author.bot :
        if int(message.id)%21 == 0 :
            lol = ["Oui", "Non"]
            await message.channel.send(lol[random.randint(0,(len(lol)-1))])
    else :
        if int(message.id)%21 == 0 and not message.author.bot:
            random.seed()
            lol = ["...",
                    "OK",
                    f"On t'as d√©j√† dit que tu as de beaux yeux ? üòç {message.author.mention} ",
                    "C'est pas faux !",
                    "Oui",
                    "Non",
                    "J'aime les fruits au sirop",
                    "J'ai d√©j√† entendu cette th√©orie",
                    "meh..",
                    "üíì",
                    "Haha, bonne blague :-) ",
                    "Nope",
                    "Je ne crois pas non"
                    ]
            await message.channel.send(lol[random.randint(0,(len(lol)-1))])

        #partie r√©action √† des messages ----------
        if re.search('bois|boire|bi√®re|berlin|sur mesure|vestiaire|chat noir|la maison|bar |biere|beer', (message.content).lower()):
            await message.add_reaction("üç∫")

        if re.search('soif', (message.content).lower()) :
            await message.add_reaction("üçª")

        if re.search('whiskey|whisky', (message.content).lower()) :
            await message.add_reaction("ü•É")

        if re.search(' bot', (message.content).lower()) :
            if int(message.id)%7 == 0 :
                lol = ["On m'apelle ?",
                        f"Tu parles de moi {message.author.mention}, tu veux te battre ?",
                        "Foutez moi la paix !",
                        "https://www.youtube.com/watch?v=bfzDbmYNm5Y"
                        ]
                await message.channel.send(lol[random.randint(0,(len(lol)-1))])


        if re.search('merci', (message.content).lower()) and not message.author.bot and int(message.id)%2 == 0 :
            lol = ["Mais de rien, c'est avec plaisir !",
                    "De rien !",
                    f"J'aime aider les gens, pas de souci {message.author.mention}",
                    f"Uniquement pour toi {message.author.mention}"
                    ]
            await message.channel.send(lol[random.randint(0,(len(lol)-1))])

        if (re.search('tg', (message.content).lower())
            or re.search('ta gueule', (message.content).lower())
            or re.search('la ferme', (message.content).lower())
            or re.search('tais toi', (message.content).lower())):
            lol = [f"Tu vas vite te calmer ! {message.author.mention}",
                    f"√áa va mal se mettre ! {message.author.mention}",
                    f"Ta maman ne t'as pas appris la politesse ? Gourgandin.e va {message.author.mention}",
                    "Pour toute r√©clamation quand √† mon comportement, le bureau des plaintes est au fond √† droite üòâ",
                    "Merci de respecter la biens√©ance et la politesse dans ce salon.",
                    ]
            await message.channel.send(lol[random.randint(0,(len(lol)-1))])
            await message.add_reaction("üò°")
            await message.add_reaction("üòí")
            await message.add_reaction("üôÑ")
            await message.add_reaction("üòû")
            await message.add_reaction("üò†")

        if re.search('alcool', (message.content).lower()) :
            await message.add_reaction("üç∑")

        if re.search('fabien|panic|panique', (message.content).lower()) :
            emoji = "<:Ipanic:648211901263642637>"
            await message.add_reaction(emoji)

    await bot.process_commands(message)


#Nombre de messages de l'auteur
@bot.command()
async def mess(ctx):
    somme = 0
    auteur = (str(ctx.message.author))
    with open("rangs.json", "r") as auteurs:
        liste = json.load(auteurs)
        nb_messages = liste[auteur]
    max = 0
    for auteur in liste :
        somme += int(liste[auteur])
        if int(liste[auteur]) > max :
            max = int(liste[auteur])
            print(max)
    if nb_messages >= max-1 :
        message = (f"Tu as envoy√© {nb_messages} messages {ctx.message.author.mention}\n T'es le top 1, le king, on ne voit que toi sur discord, f√©licitations BG")
    elif nb_messages/somme > 1/10 :
        message = (f"Tu as envoy√© {nb_messages} messages {ctx.message.author.mention}\nTu fais partie de l'√©lite, le top 10%, GG")
    elif nb_messages/somme > 1/15 :
        message = (f"Tu as envoy√© {nb_messages} messages {ctx.message.author.mention}\nPas d√©gueu, merci de rendre ce forum actif !")
    elif nb_messages/somme > 1/20 :
        message = (f"Tu as envoy√© {nb_messages} messages {ctx.message.author.mention}\nDes gens parlent plus, des gens parlent moins")
    elif nb_messages/somme > 1/25 :
        message = (f"Tu as envoy√© {nb_messages} messages {ctx.message.author.mention}\nQuelques efforts sont √† fournir")
    elif nb_messages/somme > 1/30 :
        message = (f"Tu as envoy√© {nb_messages} messages {ctx.message.author.mention}\nIl va falloir penser √† se r√©veiller")
    else :
        message = (f"Tu as envoy√© {nb_messages} messages {ctx.message.author.mention}\nJe crois que je ne peux plus rien pour toi...")
    await ctx.send(message)

#Personnes les plus bavardes du chat
@bot.command()
async def rank(ctx):
    top=5
    liste_auteurs = []
    with open("rangs.json", "r") as rangs:
        dict = json.load(rangs)
        for key, value in dict.items():
            temp = [key,value]
            liste_auteurs.append(temp)
            if len(liste_auteurs)<int(top) :
                top = int(len(liste_auteurs))
    liste_auteurs.sort(key=lambda liste_auteurs: liste_auteurs[1], reverse=True)
    sortie = ""
    i = 1
    for auteur in liste_auteurs :
        sortie = sortie + (f"Top {i} : {auteur[0]} avec {str(auteur[1])} messages\n")
        i+=1
    embed = discord.Embed(title="Qui spam le plus le salon ?", description=sortie)
    await ctx.send(embed=embed)

#************ ON AFFICHE LES BOLCHEVIKS QUI SUPPRIMENT LES MESSAGES *******

#en cas de suppression de message
@bot.event
async def on_message_delete(message):
    if len(message.content) > 2 and not message.author.bot :
        now=datetime.datetime.now()
        now=now - datetime.timedelta(hours=1, seconds=3)
        #On v√©rifie si le message a √©t√© supprim√© par son auteur ou par un mod√©rateur
        guild=message.guild
        #Pour cela, on va chercher le dernier log de suppression de message
        async for entry in guild.audit_logs(limit=1, after=now, action=discord.AuditLogAction.message_delete):
            censeur=entry.user        #on r√©cup√®re le nom du modo
            date_supr=entry.created_at
        print (f"heure suppression  \t: {now}\nheure log \t: {date_supr}")

        if now<date_supr :
            embed = discord.Embed(
                title="Alerte !",
                description=(f"{censeur} a supprim√© un message de mani√®re inopin√©e, \
                    c'est innacceptable ! \nT'es pire qu'un bolchevik {censeur}"))
            embed.add_field(
                name=("Voyons ce que contenait ce message victime de despotisme : "),
                value=(f"{message.content}\nPar : {message.author}"))
            await message.channel.send(embed=embed)
        else :
            await message.channel.send("ü§´")


#********** COMMANDE D'AIDE ****************************************************

@bot.command()
async def aide(ctx):
    embed = discord.Embed(title="Aide",
    description="Comment utiliser les diff√©rentes commandes ? \
        \nLa commande $help joue un r√¥le similaire, en moins bien \
        \nUtiliser $help <commande> te permettra (ou pas) d'obtenir des informations plus d√©taill√©s sur la commande")
    embed.add_field(
        name="$score",
        value="Mini jeu : le but est de d'entrer un nombre entre 0 et 100 apr√®s la commande. \
        Le bot te dira quel nombre il avait tir√© et la diff√©rence entre avec ton tirage")
    embed.add_field(
        name="$best",
        value="Renvoie le nom de celui ayant la plus petite diff√©rence. Je reset la commande quand quelqu'un a un 0")
    embed.add_field(
        name="$serrano, $teletchea, $mekaouche, $godart",
        value="Juste pour rire :)")
    embed.add_field(
        name="$salon",
        value="Cr√©e un salon et un r√¥le dont le nom est donn√© en argument, r√©serv√© aux admins")
    embed.add_field(
        name="$dels",
        value="Efface un salon et un r√¥le. \
        Il faut mettre le nom du salon en premier argument et le nom du r√¥le en deuxi√®me argument, r√©serv√© aux admins")
    embed.add_field(
        name="$mess",
        value="Te dit combien de messages tu as envoy√© pendant que le bot est up")
    embed.add_field(
        name="$rank",
        value="Le classement des gens les plus bavards")

    await ctx.send(embed=embed)

#************** APPEL DU BOT DE TESTING ****************************************

@bot.command(help="Apelle un b√©b√© bot afin de r√©aliser des tests √† l'√©thique discutable")
async def BOT(ctx):
    await ctx.send("Je t'envoie mon fils, il est un peu bord√©lique mais parfois il est utile...")
    with open("summon.txt", "w+") as summon :
        summon.write(str(ctx.channel.id))
    subprocess.Popen("py -3 child.py")

#************** APPEL DU BOT DE JEUX *******************************************

@bot.command(help="Appelle le bot de jeux")
async def jeux(ctx):
    await ctx.send("Prend garde, le ma√Ætre des jeux arrive !")
    with open("summon.txt", "w+") as summon :
        summon.write(str(ctx.channel.id))
    subprocess.Popen("py -3 p4.py")

#************ FERMETURE DU BOT *************************************************

@bot.command(hidden=True)
async def quit(ctx):
    if ctx.author.id == 404395089389944832 :
        await ctx.send("Au revoir")
        print("Bot √©teint sans anicroches")
        await bot.close()
    else :
        await ctx.send("nope")

@bot.command(hidden=True)
async def panic(ctx):
    pass

#************* GESTION GLOBALE DES ERREURS *************************************

@bot.event
async def on_command_error(ctx, error):
    pass
"""    if isinstance(error, command.CommandNotFound):
        await ctx.send("Cette commande n'existe pas")
    else:
        #pass
        print(error)"""

#*************MESSAGE D'ACCUEIL ************************************************

@bot.event
async def on_ready():
    print('bonjour')

#************ FIN ***********************FIN ***********************************

with open('token.txt', 'r') as token :
    t=token.read()
    bot.run(t)
